import sqlite3
import tkinter as tk
from tkinter import simpledialog, font as tkfont
import spacy
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import re
from sympy import sympify, symbols, solve, S
import os

# Load the spaCy model for natural language processing
nlp = spacy.load('en_core_web_sm')

db_path = 'chatbot.db'  # Define your database path here

def setup_database():
    db_dir = os.path.dirname(db_path)
    if db_dir:
        os.makedirs(db_dir, exist_ok=True)
    
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS qa_pairs (
            id INTEGER PRIMARY KEY,
            question TEXT,
            answer TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()

def get_answer(question):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute('SELECT question, answer FROM qa_pairs')
    qa_pairs = cursor.fetchall()
    conn.close()

    if not qa_pairs:
        return None, None

    questions, answers = zip(*qa_pairs)
    vectorizer = TfidfVectorizer()
    question_vectors = vectorizer.fit_transform(questions)

    question_vec = vectorizer.transform([question])
    similarities = cosine_similarity(question_vec, question_vectors)
    
    max_similarity_index = similarities.argmax()
    max_similarity = similarities[0, max_similarity_index]

    if max_similarity > 0.5:
        return answers[max_similarity_index], questions[max_similarity_index]
    return None, None

def add_or_update_qa_pair(question, answer):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute('SELECT answer FROM qa_pairs WHERE question = ?', (question,))
    existing_answer = cursor.fetchone()

    if existing_answer:
        cursor.execute('UPDATE qa_pairs SET answer = ? WHERE question = ?', (answer, question))
    else:
        cursor.execute('INSERT INTO qa_pairs (question, answer) VALUES (?, ?)', (question, answer))

    conn.commit()
    conn.close()

def solve_math_problem(question, decimal_places=2):
    try:
        # Strip off leading 'solve' and any non-math characters that might confuse the parser
        clean_question = re.sub(r'[^0-9\+\-\*\/\^\(\)\=\.]', ' ', question.replace('solve', '', 1).strip())
        # Use sympify to parse the cleaned question
        expr = sympify(clean_question)
        
        # Identify variables in the expression
        variables = expr.free_symbols
        if not variables:
            # Evaluate directly if no variables and format the result
            evaluated_result = expr.evalf()
            formatted_result = f"{evaluated_result:.{decimal_places}f}"  # Format to specified decimal places
            return f"The solution is {formatted_result}"
        
        # If there are variables, attempt to solve the expression
        solution = solve(expr, *variables)
        
        # Format the output depending on the type of solution
        if isinstance(solution, list):
            return ', '.join([f"{str(var)} = {float(sol):.{decimal_places}f}" for var, sol in zip(variables, solution)])
        elif isinstance(solution, dict):
            return ', '.join([f"{str(var)} = {float(sol):.{decimal_places}f}" for var, sol in solution.items()])
        return f"The solution is {solution}"
    except Exception as e:
        return f"Could not solve the problem: {str(e)}"
        
class QnAGuiApp:
    def __init__(self, root):
        self.root = root
        self.conversation_history = []
        root.title("Tachy Chat")
        root.configure(bg='#9604c7')

        chat_font = tkfont.Font(family="Helvetica", size=12)
        chat_frame = tk.Frame(root, bg='white', bd=2)
        chat_frame.pack(padx=20, pady=20, fill='both', expand=True)

        self.chat_display = tk.Text(chat_frame, height=15, width=50, bg='white', state='disabled', font=chat_font)
        self.chat_display.pack(side='left', fill='both', expand=True)

        chat_scrollbar = tk.Scrollbar(chat_frame, command=self.chat_display.yview)
        chat_scrollbar.pack(side='right', fill='y')
        self.chat_display['yscrollcommand'] = chat_scrollbar.set

        entry_font = tkfont.Font(family="Helvetica", size=12, weight="bold")
        self.question_entry = tk.Entry(root, width=40, font=entry_font, bg='white', fg='#9604c7')
        self.question_entry.pack(pady=10)
        self.question_entry.bind("<Return>", self.search_question)

        send_button = tk.Button(root, text="Send", command=self.search_question, bg='white', fg='#9604c7', font=entry_font, relief='groove')
        send_button.pack()

    def search_question(self, event=None):
        question = self.question_entry.get().strip()
        if not question:
            return
    
        # Check if the question is likely to be a math problem
        if "solve" in question.lower() or "=" in question:
            # Try to solve as a math problem
            answer = solve_math_problem(question)
        else:
            # Regular chatbot functionality
            answer, matched_question = get_answer(question)
            if not answer:
                self.update_chat("Bot: I don't know the answer. Can you tell me?")
                self.get_user_input(question)
                self.question_entry.delete(0, 'end')
                return
    
        self.update_chat(f"You: {question}")
        if answer:
            self.update_chat(f"Bot: {answer}")
        else:
            self.update_chat("Bot: I'm still learning about this, let me know the answer if you can!")
    
        self.question_entry.delete(0, 'end')



    def get_user_input(self, question):
        answer = simpledialog.askstring("Input", "What should be the answer?", parent=self.root)
        if answer:
            add_or_update_qa_pair(question, answer)
            self.update_chat("Bot: Thank you! I've learned something new.")

    def update_chat(self, message, question=None):
        self.chat_display.config(state='normal')
        self.chat_display.insert(tk.END, message + '\n\n')
        if question:
            edit_button = tk.Button(self.root, text="Edit", command=lambda q=question: self.edit_answer(q), bg='white', fg='#9604c7')
            self.chat_display.window_create(tk.END, window=edit_button)
            self.chat_display.insert(tk.END, '\n\n')
        self.chat_display.config(state='disabled')
        self.chat_display.see(tk.END)

    def edit_answer(self, question):
        new_answer = simpledialog.askstring("Edit Answer", "What is the correct answer?", parent=self.root)
        if new_answer:
            add_or_update_qa_pair(question, new_answer)
            self.update_chat(f"Bot (Updated): {new_answer}")

    def extract_variables(expr):
        # Regex to find all potential variables (letters or words that could act as symbolic variables)
        potential_vars = re.findall(r'[a-zA-Z_]+', expr)
        # Filter out known function names in SymPy
        known_functions = ['sin', 'cos', 'tan', 'exp', 'log', 'sqrt', 'pi', 'E']
        variables = set(potential_vars) - set(known_functions)
        return list(variables)
           
# Run the application
if __name__ == "__main__":
    setup_database()
    root = tk.Tk()
    root.iconbitmap(r'C:\Users\ASUS\OneDrive\Desktop\Project\Tachy\tachy.ico')  # Set the window icon
    app = QnAGuiApp(root)
    root.mainloop()
